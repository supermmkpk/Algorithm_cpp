#include <bits/stdc++.h>
using namespace std;
/**
 * 작성자 : 박봉균
 * 아이디어 : 각 레벨별 가운데의 왼쪽은 왼쪽 서브트리, 오른쪽은 오른쪽 서브트리
 * 결과: 2212KB, 0ms
 */

/* <BJ9934_S1 : 완전이진트리>
 * <시간제한: 1초>
 * 도시의 도로는 깊이가 K인 완전 이진 트리를 이루고 있다. 깊이가 K인 완전 이진 트리는 총 2^K-1개의 노드로 이루어져 있다.
 * 각 노드에는 빌딩 번호가 붙여져 있다. 또, 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.
 * 상근이는 도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓았다.
 *  1. 가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다.
 *  2. 현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다.
 *  3. 현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다.
 *  4. 현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다.
 *  5. 현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.
 * 상근이가 종이에 적은 순서가 모두 주어졌을 때, 각 레벨에 있는 빌딩의 번호를 구하시오.
[입력]
1) K. (1 ≤ K ≤ 10)
2) 방문한 빌딩 번호가 들어간 순서대로 주어진다. (1 <= 번호 < 2^K, 중복X)
[출력]
K개 줄) i번째 줄에는 레벨이 i인 빌딩의 번호를 출력한다.
*/

int a[1028], last, K;
vector<int> level[14];

void go(int left, int right, int lev)
{
    if (left > right)
        return;
    else if (left == right)
    { // 리프노드(마지막 레벨)
        level[lev].push_back(a[left]);
        return;
    }

    int mid = (left + right) / 2; // 가운데(부모)
    level[lev].push_back(a[mid]); // 현재 레벨 부모노드
    go(left, mid - 1, lev + 1);   // 현재 레벨의 왼쪽 서브트리
    go(mid + 1, right, lev + 1);  // 현재 레벨의 오른쪽 서브트리
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> K;                  // 레벨 수
    last = (int)pow(2, K) - 1; // 완전이진트리에서 노드 수는 2^레밸 - 1

    // 각 노드 배열로 입력
    for (int i = 0; i < last; i++)
    {
        cin >> a[i];
    }

    // InOrder 탐색 -> 레벨 별 저장
    go(0, last, 0);

    // 레벨 별 출력
    for (int i = 0; i < K; i++)
    {
        for (int j : level[i])
        {
            cout << j << " ";
        }
        cout << '\n';
    }

    return 0;
}