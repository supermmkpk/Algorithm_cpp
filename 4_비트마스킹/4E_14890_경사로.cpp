#include <bits/stdc++.h>
using namespace std;

/* <요약>
 * N*N 지도에서 각 칸에는 그 곳의 높이가 적혀져 있다.
 * 길: 한 행 또는 한 열 전부 (한쪽 끝에서 다른쪽 끝까지 가는 것)
 * 길을 지나가려면 모든 칸의 높이가 모두 같거나, 경사로를 놓아서 지나갈 수 있다.
 * 경사로 높이는 항상 1, 길이는 L.(개수는 매우 많아 부족할 일이 없다) 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족한다.
 *  1. 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접한다.
 *  2. 낮은 칸과 높은 칸의 높이 차이 1
 *  3. 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
 * 아래와 같은 경우에는 경사로를 놓을 수 없다.
 *  1. 경사로를 놓은 곳에 또 경사로를 놓는 경우
 *  2. 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
 *  3. 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
 *  4. 경사로를 놓다가 범위를 벗어나는 경우
 * 지나갈 수 있는 길의 개수를 구하시오.
[입력]
1) 행/열 크기 N, 경사로 길이 L (2 ≤ N ≤ 100, 1 ≤ L ≤ N)
N개 줄) 지도. (1 <= 각 칸의 높이 <= 10)
[출력]
길의 개수
 */

int a[104][104], b[104][104], cnt, ret, N, L;

void go(int arr[104][104]) {
    //행에 대해서
    for(int i = 0; i < N; i++) {
        int cnt = 1;
        int j = 0;
        for(; j < N - 1; j++) {
            if(arr[i][j] == arr[i][j+1]) //같으면 계속 cnt 증가(탐색)
                cnt++;
            else if(arr[i][j] + 1 == arr[i][j+1] && cnt >= L) //오르막 끝: cnt 1 초기화
                cnt = 1;
            else if(arr[i][j] - 1 == arr[i][j+1] && cnt >= 0) //내리막 끝: cnt 1-L 초기화
                cnt = 1 - L;
            else
                break;
        }
        //끝까지 갔고 내리막 중간에 끝나지 않았을때 길 가능
        if(cnt >= 0 && j == N - 1)
            ++ret;
    }
}
int main(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    cin >> N >> L;

    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            cin >> a[i][j];
            b[j][i] = a[i][j]; //같은 로직으로 열의 길 확인 위해 대칭 배열 b 생성
        }
    }

    go(a);
    go(b);

    cout << ret << '\n';

    return 0;
}
